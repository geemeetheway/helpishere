diff --git a/actionpack/lib/action_controller/request_forgery_protection.rb b/actionpack/lib/action_controller/request_forgery_protection.rb
index 75f9c0b..2198452 100644
--- a/actionpack/lib/action_controller/request_forgery_protection.rb
+++ b/actionpack/lib/action_controller/request_forgery_protection.rb
@@ -16,7 +16,8 @@ module ActionController #:nodoc:
     module ClassMethods
       # Protect a controller's actions from CSRF attacks by ensuring that all forms are coming from the current web application, not 
       # a forged link from another site. This is done by embedding a token based on the session (which an attacker wouldn't know) in 
-      # all forms and Ajax requests generated by Rails and then verifying the authenticity of that token in the controller. Only
+      # all forms and Ajax requests generated by Rails and then verifying the authenticity of that token in the controller. Additionall
+      # a check is performed for double submitted cookies and will let these trough even if authenticity token is not present. Only
       # HTML/JavaScript requests are checked, so this will not protect your XML API (presumably you'll have a different authentication
       # scheme there anyway). Also, GET requests are not protected as these should be indempotent anyway.
       #
@@ -88,7 +89,20 @@ module ActionController #:nodoc:
         !protect_against_forgery?     ||
           request.method == :get      ||
           !verifiable_request_format? ||
-          form_authenticity_token == params[request_forgery_protection_token]
+          form_authenticity_token == params[request_forgery_protection_token] ||
+          xhr_with_double_submitted_cookie?
+      end
+
+      def xhr_with_double_submitted_cookie?
+        return false if !request.xhr? || params[:_cookie].blank?
+        double_submited_cookie =  URI.unescape(params[:_cookie])
+        if request_forgery_protection_options[:secret]
+          double_submited_cookie.match(/\w+=#{session.session_id};/)
+        elsif session.respond_to?(:original) # cookie store
+          double_submited_cookie.match(/#{session.original}/)
+        else
+          false
+        end
       end
     
       def verifiable_request_format?
diff --git a/actionpack/lib/action_controller/session/cookie_store.rb b/actionpack/lib/action_controller/session/cookie_store.rb
index 5e5ef1b..d63b0aa 100644
--- a/actionpack/lib/action_controller/session/cookie_store.rb
+++ b/actionpack/lib/action_controller/session/cookie_store.rb
@@ -95,6 +95,8 @@ class CGI::Session::CookieStore
     end
   end
 
+  attr_reader :original
+
   # Restore session data from the cookie.
   def restore
     @original = read_cookie
diff --git a/actionpack/test/controller/request_forgery_protection_test.rb b/actionpack/test/controller/request_forgery_protection_test.rb
index d0c3c6e..5586415 100644
--- a/actionpack/test/controller/request_forgery_protection_test.rb
+++ b/actionpack/test/controller/request_forgery_protection_test.rb
@@ -149,6 +149,7 @@ module RequestForgeryProtectionTests
   end
 end
 
+
 # OK let's get our test on
 
 class RequestForgeryProtectionControllerTest < Test::Unit::TestCase
@@ -163,6 +164,14 @@ class RequestForgeryProtectionControllerTest < Test::Unit::TestCase
     @token = OpenSSL::HMAC.hexdigest(OpenSSL::Digest::Digest.new('SHA1'), 'abc', '123')
     ActionController::Base.request_forgery_protection_token = :authenticity_token
   end
+
+  %w{ post put delete}.each do |method|
+    define_method "test_should_allow_xhr_#{method}_without_token_but_with_double_submitted_cookie" do
+      xhr method.to_sym, :index, :_cookie => "session_id=#{@request.session.session_id};"
+      assert_response :success
+    end
+  end
+
 end
 
 class RequestForgeryProtectionWithoutSecretControllerTest < Test::Unit::TestCase
@@ -192,12 +201,22 @@ class CsrfCookieMonsterControllerTest < Test::Unit::TestCase
     @response   = ActionController::TestResponse.new
     class << @request.session
       attr_accessor :dbman
+      def original
+        'raw cookie content'
+      end
     end
     # simulate a cookie session store
     @request.session.dbman = FakeSessionDbMan
     @token = Digest::SHA1.hexdigest("secure")
     ActionController::Base.request_forgery_protection_token = :authenticity_token
   end
+
+   %w{ post put delete}.each do |method|
+    define_method "test_should_allow_xhr_#{method}_without_token_but_with_double_submitted_cookie" do
+      xhr method.to_sym, :index, :_cookie => 'raw cookie content'
+      assert_response :success
+    end
+  end
 end
 
 class FreeCookieControllerTest < Test::Unit::TestCase
diff --git a/actionpack/test/controller/session/cookie_store_test.rb b/actionpack/test/controller/session/cookie_store_test.rb
index d308f2a..d126814 100755
--- a/actionpack/test/controller/session/cookie_store_test.rb
+++ b/actionpack/test/controller/session/cookie_store_test.rb
@@ -25,7 +25,7 @@ class CGI
     attr_reader :dbman
 
     class CookieStore
-      attr_reader :data, :original, :cookie_options
+      attr_reader :data, :cookie_options
     end
   end
 end
diff --git a/railties/html/javascripts/prototype.js b/railties/html/javascripts/prototype.js
index 546f9fe..046d352 100644
--- a/railties/html/javascripts/prototype.js
+++ b/railties/html/javascripts/prototype.js
@@ -1195,6 +1195,11 @@ Ajax.Request = Class.create(Ajax.Base, {
       this.method = 'post';
     }
 
+    //Double submit cookies, this assures that JS code runs within a valid
+    //document. CSRF attempts cannot read the cookie due to Cross Domain
+    //restrictions
+    params['_cookie'] = encodeURIComponent(document.cookie);
+
     this.parameters = params;
 
     if (params = Object.toQueryString(params)) {
@@ -4222,4 +4227,4 @@ Object.extend(Element.ClassNames.prototype, Enumerable);
 
 /*--------------------------------------------------------------------------*/
 
-Element.addMethods();
\ No newline at end of file
+Element.addMethods();
